<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Retro ANSI Scroller</title>
    <style>
        :root {
            --bg-color: #000;
            --text-color: #33ff33; /* Verde terminal vibrante */
            --game-width: 720px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace; /* Fonte monoespaçada é crucial */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            /* Efeito de brilho CRT */
            text-shadow: 0 0 4px rgba(51, 255, 51, 0.7);
        }

        #main-container {
            width: var(--game-width);
        }

        #ui {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
            padding: 0 5px;
        }

        #game-window {
            border: 3px solid var(--text-color);
            background-color: #050505;
            position: relative;
            /* Tamanho exato para caber nossa grade de texto */
            width: 720px; 
            height: 360px;
            overflow: hidden;
        }

        /* Efeito de Scanline Retro Overlay */
        #game-window::after {
            content: " ";
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            opacity: 0.6;
        }

        pre {
            margin: 0;
            /* Ajuste fino da fonte para preencher os 720px */
            font-size: 18px; 
            line-height: 18px; 
            letter-spacing: 0px; 
            white-space: pre; /* Mantém os espaços exatos */
        }

        #status-msg {
            text-align: center;
            color: yellow;
            height: 20px;
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="ui">
            <div>SCORE: <span id="score">0000</span></div>
            <div>VIDAS: <span id="lives">3</span></div>
        </div>
        
        <div id="game-window">
            <pre id="game-screen"></pre>
        </div>
        <div id="status-msg">Use SETAS para mover | Cuidado com 'V'</div>
    </div>

    <script>
        /* --- CONFIGURAÇÕES E VARIÁVEIS GLOBAIS --- */
        const screenEl = document.getElementById('game-screen');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const statusEl = document.getElementById('status-msg');

        // Dimensões da TELA VISÍVEL (Viewport)
        // Baseado no tamanho da fonte 18px, aprox 60 chars de largura cabem em 720px
        const VIEWPORT_WIDTH = 60;  
        const VIEWPORT_HEIGHT = 20; 

        let gameState = {
            score: 0,
            lives: 3,
            isGameOver: false
        };

        let cameraX = 0;

        let player = {
            x: 5, y: 10,
            vx: 0, vy: 0,
            char: "@",
            isGrounded: false,
            spawnX: 5, spawnY: 10 // Ponto de respawn
        };

        let enemies = []; // Array para guardar os objetos vilões

        // Mapa Grande (Scrolling)
        // # = Parede/Chão, . = Ar, * = Moeda, V = Vilão, P = Posição Inicial Jogador
        const rawLevelMap = [
            "....................................................................................................",
            "....................................................................................................",
            "....................................................................................................",
            "...................................****.............................................................",
            ".................................#######.............................................***............",
            ".........***...........................................................V...........#####............",
            ".......#####...........V.....................###....................#######.........................",
            "P...................#######.......................***...............................................",
            "####.............................................#####..............................................",
            "...........###..................V.......###...................................V........***..........",
            "......***.......##...........#######......................###......#######################..........",
            "####################################################...........###..................................",
            "####################################################...V....######..................................",
            "####################################################################################################",
            "####################################################################################################",
            "....................................................................................................",
            "....................................................................................................",
            "....................................................................................................",
            "...................................................................................................."
        ];

        let mapHeight = rawLevelMap.length;
        let mapWidth = rawLevelMap[0].length;
        let currentMapData = []; // Mapa mutável (para remover moedas)

        const keys = {};

        /* --- INICIALIZAÇÃO --- */
        function initGame() {
            // Clona o mapa original para o mapa de jogo e encontra entidades
            currentMapData = [];
            enemies = [];
            for (let y = 0; y < mapHeight; y++) {
                let row = rawLevelMap[y].split('');
                for (let x = 0; x < mapWidth; x++) {
                    if (row[x] === 'P') {
                        player.spawnX = x;
                        player.spawnY = y;
                        row[x] = '.'; // Remove o marcador P do mapa
                    } else if (row[x] === 'V') {
                        // Cria um objeto inimigo
                        enemies.push({
                            x: x, y: y,
                            vx: 0.2, // Velocidade do vilão
                            char: 'V',
                            dir: 1 // Direção 1 (direita) ou -1 (esquerda)
                        });
                        row[x] = '.'; // Remove o V estático do mapa
                    }
                }
                currentMapData.push(row.join(''));
            }
            resetPlayerPos();
            gameState.score = 0;
            gameState.lives = 3;
            gameState.isGameOver = false;
            updateUI();
            statusEl.textContent = "Use SETAS para mover | Cuidado com 'V'";
            requestAnimationFrame(gameLoop);
        }

        function resetPlayerPos() {
            player.x = player.spawnX;
            player.y = player.spawnY;
            player.vx = 0;
            player.vy = 0;
        }

        /* --- INPUTS --- */
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        /* --- LÓGICA DO JOGO --- */
        function update() {
            if (gameState.isGameOver) {
                if (keys['KeyR']) initGame();
                return;
            }

            // --- JOGADOR ---
            // Física
            player.vy += 0.06; // Gravidade
            player.vx *= 0.85; // Atrito

            if (keys['ArrowLeft']) player.vx -= 0.2;
            if (keys['ArrowRight']) player.vx += 0.2;
            if (keys['ArrowUp'] && player.isGrounded) {
                player.vy = -1.1;
                player.isGrounded = false;
            }

            let nextX = player.x + player.vx;
            let nextY = player.y + player.vy;

            // Colisão com Mapa
            if (isWall(nextX, nextY)) {
                 // Colisão vertical simples (chão/teto)
                 if (player.vy > 0) player.isGrounded = true;
                 player.vy = 0;
            } else {
                 player.isGrounded = false;
                 player.y = nextY;
            }
            
            // Colisão horizontal simples
             if (!isWall(nextX, player.y)) {
                player.x = nextX;
            } else {
                player.vx = 0;
            }
            
            // Limites do mundo
            if (player.x < 0) player.x = 0;
            if (player.x > mapWidth - 1) player.x = mapWidth - 1;
            // Cair no buraco
            if (player.y > mapHeight) die();


            // --- INTERAÇÕES ---
            let pGridX = Math.round(player.x);
            let pGridY = Math.round(player.y);

            // Coletar Moeda
            if (currentMapData[pGridY] && currentMapData[pGridY][pGridX] === '*') {
                let row = currentMapData[pGridY].split('');
                row[pGridX] = '.';
                currentMapData[pGridY] = row.join('');
                gameState.score += 50;
                updateUI();
            }

            // --- INIMIGOS ---
            enemies.forEach(enemy => {
                // Movimento básico de patrulha
                let nextEX = enemy.x + (enemy.vx * enemy.dir);
                // Se bater na parede ou não tiver chão na frente, vira
                if (isWall(nextEX, enemy.y) || !isWall(nextEX, enemy.y + 1)) {
                    enemy.dir *= -1;
                } else {
                    enemy.x = nextEX;
                }

                // Colisão com Jogador (Vilão mata)
                // Verifica se as coordenadas arredondadas se sobrepõem
                if (Math.round(enemy.x) === pGridX && Math.round(enemy.y) === pGridY) {
                    die();
                }
            });

            // --- CÂMERA (Scrolling) ---
            // A câmera tenta centralizar o jogador
            cameraX = player.x - (VIEWPORT_WIDTH / 2);
            // Impede a câmera de sair dos limites do mapa
            cameraX = Math.max(0, Math.min(cameraX, mapWidth - VIEWPORT_WIDTH));
        }

        function isWall(x, y) {
            let gridX = Math.round(x);
            let gridY = Math.round(y);
            if (gridY < 0 || gridY >= mapHeight || gridX < 0 || gridX >= mapWidth) return false;
            return currentMapData[gridY][gridX] === '#';
        }

        function die() {
            gameState.lives--;
            updateUI();
            statusEl.textContent = "VOCÊ MORREU!";
            statusEl.style.color = "red";

            if (gameState.lives <= 0) {
                gameState.isGameOver = true;
                statusEl.textContent = "GAME OVER - Pressione [R] para reiniciar";
            } else {
                // Pequena pausa antes de resetar
                setTimeout(() => {
                    resetPlayerPos();
                    statusEl.textContent = "Use SETAS para mover | Cuidado com 'V'";
                    statusEl.style.color = "yellow";
                }, 1000);
            }
        }

        function updateUI() {
            scoreEl.innerText = gameState.score.toString().padStart(4, '0');
            livesEl.innerText = gameState.lives;
        }

        /* --- RENDERIZAÇÃO (DRAW) --- */
        function draw() {
            let display = "";
            // O offset da câmera arredondado para desenhar a grade corretamente
            let camOffsetInt = Math.floor(cameraX);

            // Loop apenas pela área visível (Viewport)
            for (let y = 0; y < VIEWPORT_HEIGHT; y++) {
                let line = "";
                for (let x = 0; x < VIEWPORT_WIDTH; x++) {
                    // Coordenada real no mundo
                    let worldX = x + camOffsetInt;
                    let worldY = y;

                    let charToDraw = " ";

                    // 1. Desenha Mapa Estático (se dentro dos limites)
                    if (worldY < mapHeight && worldX < mapWidth) {
                         charToDraw = currentMapData[worldY][worldX] || " ";
                    }

                    // 2. Desenha Inimigos (se estiverem nesta coordenada)
                    enemies.forEach(enemy => {
                         if (Math.round(enemy.x) === worldX && Math.round(enemy.y) === worldY) {
                            charToDraw = enemy.char;
                        }
                    });

                    // 3. Desenha Jogador (prioridade máxima)
                    if (Math.round(player.x) === worldX && Math.round(player.y) === worldY) {
                        charToDraw = player.char;
                    }
                    
                    line += charToDraw;
                }
                display += line + "\n";
            }
            screenEl.textContent = display;
        }

        function gameLoop() {
            update();
            draw();
            if (!gameState.isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Inicia o jogo
        initGame();

    </script>
</body>
</html>
